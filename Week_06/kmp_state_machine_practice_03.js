/**
 * KMP 状态机 思路
 * 通过建立一个矩阵dfa描述状态的变化，输入是字符，输出是下一个字符将会匹配到第几位pattern
 * 它针对模式串，将模式串的匹配长度作为状态，而对应的状态策略则是由dfa这样一个矩阵确定的
 * dfa主要是针对当前的状态，以及接下来的输入可能值，得到输出的状态是匹配到了第几位
 * 假设我们的当前状态为 j*， 则状态可以描述为
 * f(j* + dfa[][j*]) ==> new j*
 * 为什么用状态机之后，这个算法还是和KMP是统一思路呢
 * 1. 它也利用了预读机制，制定了一系列回退策略
 * 2. 回退策略永远只和模式串有关
 *     对于字符串KMP(PTM partial match table)，就是next数组只由模式串生成,
 *     对于DFM(deterministic finite-state automaton 确定有穷自动机)的算法，就是dfa的值只跟模式串有关
 *     ------
 *     注意看下面这张状态转移表格，dfa[][j] 对应ABC的输出各自就是一个设定值
 *     第一个维度代表主串字符，第二个维度代表模式串字符位置
 *     比如，dfa[A][0] = 1, dfa[B][0] = 0, dfa[C][0] = 0
 *     ------
 *     那么如何确定这个dfa矩阵的值?
 *     ------
 *     1. 如果当前待检验的char和模式串期望的char相同，则说明匹配成功，模式串可以+1后移
 *        即如果c = source[x] = pat.charAt(j),
 *        又有dfa[pat.charAt(j)][j] ==> j+1
 *        即为dfa[c][j] => j+1, 比如 dfa[A][0] = 1
 *     2. 对于其他字符，首先可以确定已经mismatch，设mismatch的位置为k
 *          然后我们将dfa[c][j] 和KMP字符串算法一样定义为当前串中满足pattern[0-i] = pattern[k-i, k]中的i所在的位置，
 *          这其实就和next数组是一个概念了
 *     3. 因此，和字符串KMP一样，我们同样需要建立一个类似于next数组的预读表，在这里就是dfa矩阵了
 *        再次提示，dfa矩阵只和模式串有关
 * j    pat.charAt(j)  dfa[][j]    text
 *                     A B C       ABABAC
 * 0    A              1           A
 *                      0
 *                        0
 * 1    B              1           AB
 *                       2         AA
 *                                  ABABAC
 *                        0        AC
 * @param source
 * @param pattern
 */
function match(source, pattern) {
    let dfa;

    function kmp() {
        // 根据上面的解释，dfa的第一个维度是待匹配的字符集合，第二个维度则为模式串的各个字符
        // 默认将所有状态结果设为0
        dfa = new Array(256).fill(null).map(_ => new Array(pattern.length).fill(null).map(_ => 0));
        // 设置第一个已知的状态转换（主串模式串的第一个肯定相等，所以模式串匹配代表的状态+1)
        // 至于DFA[其他字符][0] 则自然都是0了
        dfa[pattern.charAt(0)][0] = 1;
        // 求dfa其实就是求失败指针, 并且是只求去掉第一个元素后的
        // 求解过程:
        // K = 已经匹配的模式串长度 = 当前状态
        // j = 当前主串已经行走的长度
        // 主串he模式串其实都是同一个串， 并且因为k是模式串指针，所以 K <= j是必然的
        // KMP 求
        // 1. 失配情况的c下。对每一个j,状态为满足0...k === (j-k)...k情况下的最大k对应的状态
        // 2. 配对成功情况的c下。对当前的j，则状态直接转换为 j+1
        for (let k = 0, j = 1; j < pattern.length; j++) {
            // 假设j处对于当前的字符c发生了失配，
            // 因为 k < j， 所以dfa[C][K] 肯定已经求出来了
            for (let c = 0; c < 256; c++) {
                // 假设我们在 dfa[][5] 发生了失配，且我们知道状态5 的backup 为状态3
                // 则我们可以【立刻】使用状态3 的 dfa 状态机立即重新匹配,
                // 这也是类似reconsume的操作
                // 所以体现在这里就是dfa的直接复制
                // k 是 几，代表
                // -> 当前模式串是状态几
                // -> 模式串前进了几位
                // -> 模式串和主串成功匹配了几位
                // -> 对于模式串本身，在当前的j位置，[0-K] = 【j-k-1...J-1】中的k为几
                // -> 当前失配后可以直接跳到状态几继续匹配
                // -> 状态几本身的状态转移方式立马用来处理当前的状态跳转
                // -> 可以直接复制状态转移
                // -> 最终的dfa[c][j] 表示 模式串在j 状态下关于c 失配时，状态应该跳转到哪个，也就是接下来模式串应该从哪里开始匹配
                // -> 如果实际上dfa[c][j] 并不是失配，则会在下面一步被 j+1状态覆盖
                // 关键就是不要被这个c迷惑了，这个c和整体的逻辑理解并没啥关系，同时要理解dfa矩阵是一个静态数据隐含动态过程的状态机就好
                // 把这个c理解为一个感性的任意字符，对于任意字符，只要在j处发生失配，
                // 很自然的需要回退到当前循环中k指示的位置，和pmt的不同就是，pmt会保留j.fail = k
                // 而DFM 是只将k的状态变化复制给j，
                // 本身这个映射关系只在计算时存在，计算完毕之后就不再能够被复原了
                // 并且关于当前字符对任何一个状态下的失配情况，我们都已经预先记录过了，典型的动态规划
                // 如果dfa[c][k] !== k+1, 状态则会继续回退，直到成为0或者得到某个k'+1
                dfa[c][j] = dfa[c][k];
            }
            // 将一开始其中错误设置的成功匹配的c的状态设置为j+1，
            // 实际上也只有这一个状态能够使得模式串"前进"，其他的都是回退
            // 自此，当前主串字符的dfa记录完毕
            dfa[pattern.charAt(j)][j] = j + 1;
            // 这一步蕴含了比较主串he模式串当前字符，
            // 并且将模式串按照状态转移矩阵输出状态适当调整的过程
            // 这一步也是为了接下来为下一轮j计算最大k
            k = dfa[pattern.charAt(j)][k];
        }
    }

    // 我们已经获得了dfa状态机，就可以读取主串来进行状态流转了
    // 实际上，dfa状态机已经构建了一个完整的针对任何字符的状态转移过程，这里做的事情就只是查表了
    function search() {
        let i, j;
        // 如果主串检查到达了长度，说明匹配失败，会退出
        // 如果模式串检查到达了长度，说明匹配成功，也会退出，不过此时的i就会小于source的长度了
        for (i = 0, j = 0; i < source.length && j < pattern.length; i++) {
            j = dfa[source.charAt(i)][j];
        }
        // 如果最终的状态 === 模式串长度，说明已经成功匹配到了。当前的i - pattern 长度即为匹配到的开始位置
        if (j === pattern.length) {
            return i - pattern.length;
        } else {
            return false;
        }
    }

    kmp();
    return search();
}



match('abababc', 'ababc');
