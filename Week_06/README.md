### 状态机
1. 每一个状态都是一个机器
   - 所有的机器接受的输入格式，类型是一致的
   - 所有的机器应该无副作用，是纯函数
2. 每一个机器都知道下一个状态
    - 每个机器都有确定的下一个状态，输出仅仅和当前状态有关（Moore)
    - 每个机器根据输入决定下一个状态，除了跟当前状态，还跟输入有关 (Mealy)

### KMP 状态机 思路
  通过建立一个矩阵dfa描述状态的变化，输入是字符，输出是下一个字符将会匹配到第几位pattern
  它针对模式串，将模式串的匹配长度作为状态，而对应的状态策略则是由dfa这样一个矩阵确定的
  dfa主要是针对当前的状态，以及接下来的输入可能值，得到输出的状态是匹配到了第几位
  假设我们的当前状态为 j*， 则状态可以描述为
  f(j* + dfa[][j*]) ==> new j*
  为什么用状态机之后，这个算法还是和KMP是统一思路呢
  1. 它也利用了预读机制，制定了一系列回退策略
  2. 回退策略永远只和模式串有关
      对于字符串KMP(PTM partial match table)，就是next数组只由模式串生成,
      对于DFM(deterministic finite-state automaton 确定有穷自动机)的算法，就是dfa的值只跟模式串有关
  注意看下面这张状态转移表格，dfa[][j] 对应ABC的输出各自就是一个设定值
      第一个维度代表主串字符，第二个维度代表模式串字符位置
      比如，dfa[A][0] = 1, dfa[B][0] = 0, dfa[C][0] = 0

  #### 那么如何确定这个dfa矩阵的值?
      1. 如果当前待检验的char和模式串期望的char相同，则说明匹配成功，模式串可以+1后移
         即如果c = source[x] = pat.charAt(j),
         又有dfa[pat.charAt(j)][j] ==> j+1
         即为dfa[c][j] => j+1, 比如 dfa[A][0] = 1
      2. 对于其他字符，首先可以确定已经mismatch，设mismatch的位置为k
           然后我们将dfa[c][j] 和KMP字符串算法一样定义为当前串中满足pattern[0-i] = pattern[k-i, k]中的i所在的位置，
           这其实就和next数组是一个概念了
      3. 因此，和字符串KMP一样，我们同样需要建立一个类似于next数组的预读表，在这里就是dfa矩阵了
         再次提示，dfa矩阵只和模式串有关
        
  ```
  j    pat.charAt(j)  dfa[][j]    text
                      A B C       ABABAC
  0    A              1           A
                       0
                         0
  1    B              1           AB
                        2         AA
                                   ABABAC
                         0        AC
  ```
